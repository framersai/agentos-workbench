import{r as R,a as z,p as O,u as se,B as L,g as ue}from"./index-BUjQjMyU.js";function ce(e,n){for(var s=0;s<n.length;s++){const l=n[s];if(typeof l!="string"&&!Array.isArray(l)){for(const t in l)if(t!=="default"&&!(t in e)){const a=Object.getOwnPropertyDescriptor(l,t);a&&Object.defineProperty(e,t,a.get?a:{enumerable:!0,get:()=>l[t]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}var C={exports:{}};function ne(e){throw new Error('Could not dynamically require "'+e+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var v={};v.getBooleanOption=(e,n)=>{let s=!1;if(n in e&&typeof(s=e[n])!="boolean")throw new TypeError(`Expected the "${n}" option to be a boolean`);return s};v.cppdb=Symbol();v.inspect=Symbol.for("nodejs.util.inspect.custom");const U={value:"SqliteError",writable:!0,enumerable:!1,configurable:!0};function _(e,n){if(new.target!==_)return new _(e,n);if(typeof n!="string")throw new TypeError("Expected second argument to be a string");Error.call(this,e),U.value=""+e,Object.defineProperty(this,"message",U),Error.captureStackTrace(this,_),this.code=n}Object.setPrototypeOf(_,Error);Object.setPrototypeOf(_.prototype,Error.prototype);Object.defineProperty(_.prototype,"name",U);var oe=_,I={exports:{}},S,N;function le(){if(N)return S;N=1;var e=R().sep||"/";S=n;function n(s){if(typeof s!="string"||s.length<=7||s.substring(0,7)!="file://")throw new TypeError("must pass in a file:// URI to convert to a file path");var l=decodeURI(s.substring(7)),t=l.indexOf("/"),a=l.substring(0,t),o=l.substring(t+1);return a=="localhost"&&(a=""),a&&(a=e+e+a),o=o.replace(/^(.+)\|/,"$1:"),e=="\\"&&(o=o.replace(/\//g,"\\")),/^.+\:/.test(o)||(o=e+o),a+o}return S}var W;function fe(){return W||(W=1,function(e,n){var s={},l=z,t=R(),a=le(),o=t.join,c=t.dirname,h=l.accessSync&&function(g){try{l.accessSync(g)}catch{return!1}return!0}||l.existsSync||t.existsSync,p={arrow:s.NODE_BINDINGS_ARROW||" â†’ ",compiled:s.NODE_BINDINGS_COMPILED_DIR||"compiled",platform:O.platform,arch:O.arch,nodePreGyp:"node-v"+O.versions.modules+"-"+O.platform+"-"+O.arch,version:O.versions.node,bindings:"bindings.node",try:[["module_root","build","bindings"],["module_root","build","Debug","bindings"],["module_root","build","Release","bindings"],["module_root","out","Debug","bindings"],["module_root","Debug","bindings"],["module_root","out","Release","bindings"],["module_root","Release","bindings"],["module_root","build","default","bindings"],["module_root","compiled","version","platform","arch","bindings"],["module_root","addon-build","release","install-root","bindings"],["module_root","addon-build","debug","install-root","bindings"],["module_root","addon-build","default","install-root","bindings"],["module_root","lib","binding","nodePreGyp","bindings"]]};function y(g){typeof g=="string"?g={bindings:g}:g||(g={}),Object.keys(p).map(function(m){m in g||(g[m]=p[m])}),g.module_root||(g.module_root=n.getRoot(n.getFileName())),t.extname(g.bindings)!=".node"&&(g.bindings+=".node");for(var u=typeof __webpack_require__=="function"?__non_webpack_require__:ne,i=[],r=0,b=g.try.length,d,f,w;r<b;r++){d=o.apply(null,g.try[r].map(function(m){return g[m]||m})),i.push(d);try{return f=g.path?u.resolve(d):u(d),g.path||(f.path=d),f}catch(m){if(m.code!=="MODULE_NOT_FOUND"&&m.code!=="QUALIFIED_PATH_RESOLUTION_FAILED"&&!/not find/i.test(m.message))throw m}}throw w=new Error(`Could not locate the bindings file. Tried:
`+i.map(function(m){return g.arrow+m}).join(`
`)),w.tries=i,w}e.exports=n=y,n.getFileName=function(u){var i=Error.prepareStackTrace,r=Error.stackTraceLimit,b={},d;Error.stackTraceLimit=10,Error.prepareStackTrace=function(w,m){for(var $=0,T=m.length;$<T;$++)if(d=m[$].getFileName(),d!==__filename)if(u){if(d!==u)return}else return},Error.captureStackTrace(b),b.stack,Error.prepareStackTrace=i,Error.stackTraceLimit=r;var f="file://";return d.indexOf(f)===0&&(d=a(d)),d},n.getRoot=function(u){for(var i=c(u),r;;){if(i==="."&&(i=O.cwd()),h(o(i,"package.json"))||h(o(i,"node_modules")))return i;if(r===i)throw new Error('Could not find module root given file: "'+u+'". Do you have a `package.json` file? ');r=i,i=o(i,"..")}}}(I,I.exports)),I.exports}var x={},G;function pe(){if(G)return x;G=1;const{cppdb:e}=v;return x.prepare=function(s){return this[e].prepare(s,this,!1)},x.exec=function(s){return this[e].exec(s),this},x.close=function(){return this[e].close(),this},x.loadExtension=function(...s){return this[e].loadExtension(...s),this},x.defaultSafeIntegers=function(...s){return this[e].defaultSafeIntegers(...s),this},x.unsafeMode=function(...s){return this[e].unsafeMode(...s),this},x.getters={name:{get:function(){return this[e].name},enumerable:!0},open:{get:function(){return this[e].open},enumerable:!0},inTransaction:{get:function(){return this[e].inTransaction},enumerable:!0},readonly:{get:function(){return this[e].readonly},enumerable:!0},memory:{get:function(){return this[e].memory},enumerable:!0}},x}var P,H;function de(){if(H)return P;H=1;const{cppdb:e}=v,n=new WeakMap;P=function(a){if(typeof a!="function")throw new TypeError("Expected first argument to be a function");const o=this[e],c=s(o,this),{apply:h}=Function.prototype,p={default:{value:l(h,a,o,c.default)},deferred:{value:l(h,a,o,c.deferred)},immediate:{value:l(h,a,o,c.immediate)},exclusive:{value:l(h,a,o,c.exclusive)},database:{value:this,enumerable:!0}};return Object.defineProperties(p.default.value,p),Object.defineProperties(p.deferred.value,p),Object.defineProperties(p.immediate.value,p),Object.defineProperties(p.exclusive.value,p),p.default.value};const s=(t,a)=>{let o=n.get(t);if(!o){const c={commit:t.prepare("COMMIT",a,!1),rollback:t.prepare("ROLLBACK",a,!1),savepoint:t.prepare("SAVEPOINT `	_bs3.	`",a,!1),release:t.prepare("RELEASE `	_bs3.	`",a,!1),rollbackTo:t.prepare("ROLLBACK TO `	_bs3.	`",a,!1)};n.set(t,o={default:Object.assign({begin:t.prepare("BEGIN",a,!1)},c),deferred:Object.assign({begin:t.prepare("BEGIN DEFERRED",a,!1)},c),immediate:Object.assign({begin:t.prepare("BEGIN IMMEDIATE",a,!1)},c),exclusive:Object.assign({begin:t.prepare("BEGIN EXCLUSIVE",a,!1)},c)})}return o},l=(t,a,o,{begin:c,commit:h,rollback:p,savepoint:y,release:g,rollbackTo:u})=>function(){let r,b,d;o.inTransaction?(r=y,b=g,d=u):(r=c,b=h,d=p),r.run();try{const f=t.call(a,this,arguments);if(f&&typeof f.then=="function")throw new TypeError("Transaction function cannot return a promise");return b.run(),f}catch(f){throw o.inTransaction&&(d.run(),d!==p&&b.run()),f}};return P}var D,K;function he(){if(K)return D;K=1;const{getBooleanOption:e,cppdb:n}=v;return D=function(l,t){if(t==null&&(t={}),typeof l!="string")throw new TypeError("Expected first argument to be a string");if(typeof t!="object")throw new TypeError("Expected second argument to be an options object");const a=e(t,"simple"),o=this[n].prepare(`PRAGMA ${l}`,this,!0);return a?o.pluck().get():o.all()},D}var B,Q;function ge(){if(Q)return B;Q=1;const e=z,n=R(),{promisify:s}=se,{cppdb:l}=v,t=s(e.access);B=async function(c,h){if(h==null&&(h={}),typeof c!="string")throw new TypeError("Expected first argument to be a string");if(typeof h!="object")throw new TypeError("Expected second argument to be an options object");c=c.trim();const p="attached"in h?h.attached:"main",y="progress"in h?h.progress:null;if(!c)throw new TypeError("Backup filename cannot be an empty string");if(c===":memory:")throw new TypeError('Invalid backup filename ":memory:"');if(typeof p!="string")throw new TypeError('Expected the "attached" option to be a string');if(!p)throw new TypeError('The "attached" option cannot be an empty string');if(y!=null&&typeof y!="function")throw new TypeError('Expected the "progress" option to be a function');await t(n.dirname(c)).catch(()=>{throw new TypeError("Cannot save backup because the directory does not exist")});const g=await t(c).then(()=>!1,()=>!0);return a(this[l].backup(this,p,c,g),y||null)};const a=(o,c)=>{let h=0,p=!0;return new Promise((y,g)=>{setImmediate(function u(){try{const i=o.transfer(h);if(!i.remainingPages){o.close(),y(i);return}if(p&&(p=!1,h=100),c){const r=c(i);if(r!==void 0)if(typeof r=="number"&&r===r)h=Math.max(0,Math.min(2147483647,Math.round(r)));else throw new TypeError("Expected progress callback to return a number or undefined")}setImmediate(u)}catch(i){o.close(),g(i)}})})};return B}var A,X;function be(){if(X)return A;X=1;const{cppdb:e}=v;return A=function(s){if(s==null&&(s={}),typeof s!="object")throw new TypeError("Expected first argument to be an options object");const l="attached"in s?s.attached:"main";if(typeof l!="string")throw new TypeError('Expected the "attached" option to be a string');if(!l)throw new TypeError('The "attached" option cannot be an empty string');return this[e].serialize(l)},A}var k,J;function ye(){if(J)return k;J=1;const{getBooleanOption:e,cppdb:n}=v;return k=function(l,t,a){if(t==null&&(t={}),typeof t=="function"&&(a=t,t={}),typeof l!="string")throw new TypeError("Expected first argument to be a string");if(typeof a!="function")throw new TypeError("Expected last argument to be a function");if(typeof t!="object")throw new TypeError("Expected second argument to be an options object");if(!l)throw new TypeError("User-defined function name cannot be an empty string");const o="safeIntegers"in t?+e(t,"safeIntegers"):2,c=e(t,"deterministic"),h=e(t,"directOnly"),p=e(t,"varargs");let y=-1;if(!p){if(y=a.length,!Number.isInteger(y)||y<0)throw new TypeError("Expected function.length to be a positive integer");if(y>100)throw new RangeError("User-defined functions cannot have more than 100 arguments")}return this[n].function(a,l,y,o,c,h),this},k}var F,Y;function we(){if(Y)return F;Y=1;const{getBooleanOption:e,cppdb:n}=v;F=function(a,o){if(typeof a!="string")throw new TypeError("Expected first argument to be a string");if(typeof o!="object"||o===null)throw new TypeError("Expected second argument to be an options object");if(!a)throw new TypeError("User-defined function name cannot be an empty string");const c="start"in o?o.start:null,h=s(o,"step",!0),p=s(o,"inverse",!1),y=s(o,"result",!1),g="safeIntegers"in o?+e(o,"safeIntegers"):2,u=e(o,"deterministic"),i=e(o,"directOnly"),r=e(o,"varargs");let b=-1;if(!r&&(b=Math.max(l(h),p?l(p):0),b>0&&(b-=1),b>100))throw new RangeError("User-defined functions cannot have more than 100 arguments");return this[n].aggregate(c,h,p,y,a,b,g,u,i),this};const s=(t,a,o)=>{const c=a in t?t[a]:null;if(typeof c=="function")return c;if(c!=null)throw new TypeError(`Expected the "${a}" option to be a function`);if(o)throw new TypeError(`Missing required option "${a}"`);return null},l=({length:t})=>{if(Number.isInteger(t)&&t>=0)return t;throw new TypeError("Expected function.length to be a positive integer")};return F}var M,Z;function me(){if(Z)return M;Z=1;const{cppdb:e}=v;M=function(i,r){if(typeof i!="string")throw new TypeError("Expected first argument to be a string");if(!i)throw new TypeError("Virtual table module name cannot be an empty string");let b=!1;if(typeof r=="object"&&r!==null)b=!0,r=g(s(r,"used",i));else{if(typeof r!="function")throw new TypeError("Expected second argument to be a function or a table definition object");r=n(r)}return this[e].table(r,i,b),this};function n(u){return function(r,b,d,...f){const w={module:r,database:b,table:d},m=h.call(u,w,f);if(typeof m!="object"||m===null)throw new TypeError(`Virtual table module "${r}" did not return a table definition object`);return s(m,"returned",r)}}function s(u,i,r){if(!c.call(u,"rows"))throw new TypeError(`Virtual table module "${r}" ${i} a table definition without a "rows" property`);if(!c.call(u,"columns"))throw new TypeError(`Virtual table module "${r}" ${i} a table definition without a "columns" property`);const b=u.rows;if(typeof b!="function"||Object.getPrototypeOf(b)!==p)throw new TypeError(`Virtual table module "${r}" ${i} a table definition with an invalid "rows" property (should be a generator function)`);let d=u.columns;if(!Array.isArray(d)||!(d=[...d]).every(T=>typeof T=="string"))throw new TypeError(`Virtual table module "${r}" ${i} a table definition with an invalid "columns" property (should be an array of strings)`);if(d.length!==new Set(d).size)throw new TypeError(`Virtual table module "${r}" ${i} a table definition with duplicate column names`);if(!d.length)throw new RangeError(`Virtual table module "${r}" ${i} a table definition with zero columns`);let f;if(c.call(u,"parameters")){if(f=u.parameters,!Array.isArray(f)||!(f=[...f]).every(T=>typeof T=="string"))throw new TypeError(`Virtual table module "${r}" ${i} a table definition with an invalid "parameters" property (should be an array of strings)`)}else f=o(b);if(f.length!==new Set(f).size)throw new TypeError(`Virtual table module "${r}" ${i} a table definition with duplicate parameter names`);if(f.length>32)throw new RangeError(`Virtual table module "${r}" ${i} a table definition with more than the maximum number of 32 parameters`);for(const T of f)if(d.includes(T))throw new TypeError(`Virtual table module "${r}" ${i} a table definition with column "${T}" which was ambiguously defined as both a column and parameter`);let w=2;if(c.call(u,"safeIntegers")){const T=u.safeIntegers;if(typeof T!="boolean")throw new TypeError(`Virtual table module "${r}" ${i} a table definition with an invalid "safeIntegers" property (should be a boolean)`);w=+T}let m=!1;if(c.call(u,"directOnly")&&(m=u.directOnly,typeof m!="boolean"))throw new TypeError(`Virtual table module "${r}" ${i} a table definition with an invalid "directOnly" property (should be a boolean)`);return[`CREATE TABLE x(${[...f.map(y).map(T=>`${T} HIDDEN`),...d.map(y)].join(", ")});`,l(b,new Map(d.map((T,ae)=>[T,f.length+ae])),r),f,w,m]}function l(u,i,r){return function*(...d){const f=d.map(w=>L.isBuffer(w)?L.from(w):w);for(let w=0;w<i.size;++w)f.push(null);for(const w of u(...d))if(Array.isArray(w))t(w,f,i.size,r),yield f;else if(typeof w=="object"&&w!==null)a(w,f,i,r),yield f;else throw new TypeError(`Virtual table module "${r}" yielded something that isn't a valid row object`)}}function t(u,i,r,b){if(u.length!==r)throw new TypeError(`Virtual table module "${b}" yielded a row with an incorrect number of columns`);const d=i.length-r;for(let f=0;f<r;++f)i[f+d]=u[f]}function a(u,i,r,b){let d=0;for(const f of Object.keys(u)){const w=r.get(f);if(w===void 0)throw new TypeError(`Virtual table module "${b}" yielded a row with an undeclared column "${f}"`);i[w]=u[f],d+=1}if(d!==r.size)throw new TypeError(`Virtual table module "${b}" yielded a row with missing columns`)}function o({length:u}){if(!Number.isInteger(u)||u<0)throw new TypeError("Expected function.length to be a positive integer");const i=[];for(let r=0;r<u;++r)i.push(`$${r+1}`);return i}const{hasOwnProperty:c}=Object.prototype,{apply:h}=Function.prototype,p=Object.getPrototypeOf(function*(){}),y=u=>`"${u.replace(/"/g,'""')}"`,g=u=>()=>u;return M}var V,ee;function Ee(){if(ee)return V;ee=1;const e=function(){};return V=function(s,l){return Object.assign(new e,this)},V}const Te=z,te=R(),q=v,ve=oe;let re;function E(e,n){if(new.target==null)return new E(e,n);let s;if(L.isBuffer(e)&&(s=e,e=":memory:"),e==null&&(e=""),n==null&&(n={}),typeof e!="string")throw new TypeError("Expected first argument to be a string");if(typeof n!="object")throw new TypeError("Expected second argument to be an options object");if("readOnly"in n)throw new TypeError('Misspelled option "readOnly" should be "readonly"');if("memory"in n)throw new TypeError('Option "memory" was removed in v7.0.0 (use ":memory:" filename instead)');const l=e.trim(),t=l===""||l===":memory:",a=q.getBooleanOption(n,"readonly"),o=q.getBooleanOption(n,"fileMustExist"),c="timeout"in n?n.timeout:5e3,h="verbose"in n?n.verbose:null,p="nativeBinding"in n?n.nativeBinding:null;if(a&&t&&!s)throw new TypeError("In-memory/temporary databases cannot be readonly");if(!Number.isInteger(c)||c<0)throw new TypeError('Expected the "timeout" option to be a positive integer');if(c>2147483647)throw new RangeError('Option "timeout" cannot be greater than 2147483647');if(h!=null&&typeof h!="function")throw new TypeError('Expected the "verbose" option to be a function');if(p!=null&&typeof p!="string"&&typeof p!="object")throw new TypeError('Expected the "nativeBinding" option to be a string or addon object');let y;if(p==null?y=re||(re=fe()("better_sqlite3.node")):typeof p=="string"?y=(typeof __non_webpack_require__=="function"?__non_webpack_require__:ne)(te.resolve(p).replace(/(\.node)?$/,".node")):y=p,y.isInitialized||(y.setErrorConstructor(ve),y.isInitialized=!0),!t&&!l.startsWith("file:")&&!Te.existsSync(te.dirname(l)))throw new TypeError("Cannot open database because the directory does not exist");Object.defineProperties(this,{[q.cppdb]:{value:new y.Database(l,e,t,a,o,c,h||null,s||null)},...j.getters})}const j=pe();E.prototype.prepare=j.prepare;E.prototype.transaction=de();E.prototype.pragma=he();E.prototype.backup=ge();E.prototype.serialize=be();E.prototype.function=ye();E.prototype.aggregate=we();E.prototype.table=me();E.prototype.loadExtension=j.loadExtension;E.prototype.exec=j.exec;E.prototype.close=j.close;E.prototype.defaultSafeIntegers=j.defaultSafeIntegers;E.prototype.unsafeMode=j.unsafeMode;E.prototype[q.inspect]=Ee();var xe=E;C.exports=xe;var Oe=C.exports.SqliteError=oe,ie=C.exports;const _e=ue(ie),$e=ce({__proto__:null,SqliteError:Oe,default:_e},[ie]);export{$e as i};
